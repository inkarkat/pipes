#!/bin/bash
###############################################################################
##
# FILE: 	pipethrough1
# PRODUCT:	tools
# AUTHOR: 	/^--
# DATE CREATED:	15-Jun-2016
#
###############################################################################
# REVISION	DATE		REMARKS
#	021	30-Apr-2019	ENH: Also support {} placeholder in COMMAND
#				as an alternative to appending the file.
#	020	15-Apr-2019	Preserve original file mode by using cp && rm
#				instead of mv: "In the absence of --preserve,
#				the permissions of existing destination files
#				are unchanged."
#	019	13-May-2018	ENH: Add --piped option for actual piping via
#				stdin. Some COMMANDs do not support FILE
#				arguments or behave differently (e.g.
#				colordiff).
#	018	17-Jun-2016	BUG: diff arguments are reversed.
#				ENH: Add --warn-on-change and
#				--warn-unless-change.
#				FIX: Correct command-line summary for
#				--message-... options.
#				FIX: Don't enable checkChanges on
#				--message-on-change ''.
#	017	16-Jun-2016	ENH: Add built-in messaging via
#				--message-on-success, --message-on-failure,
#				--message-on-error, --message-subject; this is
#				easier for the client than checking the script's
#				exit status.
#				ENH: Add --message-on-change and support
#				checking for changes without error.
#	016	01-Jan-2004	file creation from pipethrough
###############################################################################

printShortUsage()
{
    printf 'Usage: %q %s\n' $(basename "$1") '[-v|--verbose] [-p|--piped] [-b|--backup EXT] [--test-only|(--diff-only|--diff [--diff-cmd CMD] [--diff-options OPT])] [--error-unless-change|--error-on-change] [--message-on-change MSG] [--message-on-success MSG] [--message-on-failure MSG] [--message-on-error MSG] ([--message-subject SUBJECT] [--warn-on-change|--warn-unless-change]) [-?|-h|--help] ...'
    printf 'Usage: %q %s\n' $(basename "$1") '[...] -c|--command "COMMANDLINE [{}] ..." [-c ...] FILE'
    printf 'Usage: %q %s\n' $(basename "$1") '[...] SIMPLECOMMAND [ARGUMENTS ...] FILE'
}
printUsage()
{
    # This is the short help when launched with no or incorrect arguments.
    # It is printed to stderr to avoid accidental processing.
    printShortUsage "$1" >&2
    printf >&2 'Try %q --help for more information.\n' "$(basename "$1")"
}
printLongUsage()
{
    cat <<HELPDESCRIPTION
Passes FILE through an external COMMAND (by passing the FILE spec as the last
command-line argument, or replacing any {} marker inside COMMAND, or
alternatively piping the FILE contents in through standard input) and writes the
output back into the same FILE.
HELPDESCRIPTION
    echo
    printShortUsage "$1"
    cat <<HELPTEXT
    --verbose|-v	    Show each executed command on stderr.
    --piped|-p		    Pass FILE contents via stdin into COMMAND instead of
			    by appending FILE as the last command-line argument.
    --backup|-b		    Create a backup of the original file with file
			    extension EXT.
    --test-only		    Just test for change, don't persist.
    --diff-only		    Only show differences done by COMMAND, don't persist.
    --diff		    Also show differences done by COMMAND, and overwrite.
    --diff-cmd CMD	    Use CMD as the diff command.
    --diff-options OPT	    Options passed to diff; default -u (unified diff).
    --error-unless-change   Exit 1 if COMMAND didn't change the FILE.
    --error-on-change	    Exit 1 if COMMAND changed the FILE.
    --message-on-change MSG Print MSG to stderr if COMMAND changed the FILE.
    --message-on-success MSG
			    Print MSG to stderr if COMMAND succeeds.
    --message-on-failure MSG
			    Print MSG to stderr if COMMAND fails.
    --message-on-error MSG  Print MSG to stderr if processing had an error
			    (--error-on-change, --error-unless-change).
			    FILE can be embedded in the message via %q.
    --message-subject SUBJECT
			    Print a status message (change, success, failure,
			    error) to stderr. Basically all of the
			    --message-on-... options in one. Individual messages
			    can still be overridden via the --message-on-...
			    parameters.
    --warn-on-change	    The status message on change will be a warning
			    message instead of an informational one.
    --warn-unless-change    The status message on success (without change) will
			    be a warning message instead of an informational
			    one.
EXIT STATUS:
      0 if it succeeds
    123 if the COMMAND exited with status 1-125
    124 if the COMMAND exited with status 255
      1 if an error was raised (--error-on-change, --error-unless-change)
      2 if it was invoked in a wrong way, e.g. missing FILE
HELPTEXT
}


action=overwrite
check=:
errorOn=
backupExtension=
commandArgumentNum=
diffCommand=diff; type -t colordiff >/dev/null && diffCommand=colordiff # Highlight diff output if available.
diffOptions=-u
isPiped=
commandJoiner=';'
isVerbose=
warnOn=
unset messageOnChange
unset messageOnSuccess
unset messageOnFailure
unset messageOnError
messageSubject=
while [ $# -ne 0 ]
do
    case "$1" in
	--help|-h|-\?)	shift; printLongUsage "$0"; exit 0;;
	--command|-c)	shift; commands+=(${commands:+$commandJoiner} "$1"); isNeedEval=t; shift;;
	--verbose|-v)	shift; isVerbose=t;;
	--piped|-p)	shift; isPiped=t; commandJoiner='|';;
	--backup|-b)	shift; backupExtension="$1"; shift;;
	--test-only)	shift; action=testChanges;;
	--diff-only)	shift; action=diffChanges;;
	--diff)		shift; action=diffAndOverwrite;;
	--diff-options)		shift; diffOptions="$1"; shift;;
	--diff-cmd)		shift; diffCommand="$1"; shift;;
	--error-unless-change)	shift
				if [ "$errorOn" = 1 ]; then
				    echo >&2 "ERROR: Cannot specify both --error-unless-change and --error-on-change at once!"
				    printShortUsage "$0"
				    exit 2;
				fi
				check=checkError
				errorOn=0
				;;
	--error-on-change)	shift
				if [ "$errorOn" = 0 ]; then
				    echo >&2 "ERROR: Cannot specify both --error-unless-change and --error-on-change at once!"
				    printShortUsage "$0"
				    exit 2;
				fi
				check=checkError
				errorOn=1
				;;
	--message-on-change)	shift
				[ "$1" -a "$check" = ':' ] && check=checkChanges
				messageOnChange="$1"
				shift
				;;
	--message-on-success)		shift; messageOnSuccess="$1"; shift;;
	--message-on-failure)		shift; messageOnFailure="$1"; shift;;
	--message-on-error)		shift; messageOnError="$1"; shift;;
	--message-subject)		shift; messageSubject="$1"; shift;;
	--warn-on-change)		shift; warnOn=1;;
	--warn-unless-change)		shift; warnOn=0;;
	--)		break;;
	-*)		{ echo "ERROR: Unknown option \"$1\"!"; echo; printShortUsage "$0"; } >&2; exit 2;;
	*)		break;;
    esac
done
if [ $# -eq 0 ]; then
    printUsage "$0" >&2
    exit 2
fi
if [ "$messageSubject" ]; then
    if [ ! "${messageOnChange+t}" ]; then
	case "$warnOn" in
	    1)	messageOnChange="Warning: $messageSubject changed %q";;
	    *)	messageOnChange="$messageSubject changed %q";;
	esac
	[ "$check" = ':' ] && check=checkChanges
    fi
    case "$warnOn" in
	0)  if [ "$check" = ':' ]; then
		echo >&2 "ERROR: --warn-unless-change cannot be specified when change checking isn't enabled"
		exit 2
	    fi
	    : ${messageOnSuccess="Warning: $messageSubject did not change %q"}
	    ;;
	*)  : ${messageOnSuccess="Successfully performed $messageSubject on %q"};;
    esac
    : ${messageOnFailure="ERROR: Failed to $messageSubject on %q"}
    case "$errorOn" in
	0)  : ${messageOnError="ERROR: $messageSubject did not change %q"};;
	1)  : ${messageOnError="ERROR: $messageSubject changed %q"};;
    esac
fi

typeset -a simpleCommand=("${@:1:$(($#-1))}")
typeset file="${!#}"
if [ ${#simpleCommand[@]} -gt 0 ]; then
    if [ "$isNeedEval" ]; then
	# Combine --command and SIMPLECOMMAND; need to quote SIMPLECOMMAND to
	# undo the effects of eval.
	printf -v quotedSimpleCommand '%q ' "${simpleCommand[@]}"
	quotedSimpleCommand="${quotedSimpleCommand% }"
	commands+=(${commands:+$commandJoiner} "${quotedSimpleCommand//\\\{\\\}/\{\}}")	# %q escapes {}, we don't want that to have it interpolated later.
    else
	commands=("${simpleCommand[@]}")
    fi
fi
if [ ${#commands[@]} -eq 0 ]; then
    echo >&2 'ERROR: No COMMAND(s) specified; need to pass -c|--command "COMMANDLINE", or SIMPLECOMMAND.'
    exit 2
fi



message()
{
    if [ "$1" ]; then
	printf "$1\\n" "$2"
    fi
}

overwrite()
{
    cp --force -- "$1" "$2" && rm --force -- "$1"
}
testChanges()
{
    return 0
}
diffChanges()
{
    eval "$diffCommand" "$diffOptions" '"$2" "$1"'
    return 0	# Do not interpret differences as failure; we have the separate --error-on-change and --error-unless-change for that.
}
diffAndOverwrite()
{
    diffChanges "$1" "$2"
    overwrite "$1" "$2"
}

# The $check is done in a subprocess, so we need to send a signal to the main
# script in order to pass the information about whether a change has been done.
mainPID=$$
isChange=
onChangeReported()
{
    isChange=t
}
trap onChangeReported SIGUSR1
checkChanges()
{
    cmp --silent "$1" "$2"
    case $? in
	2) exit 1;;	# cmp had trouble
	1) if [ "$messageOnChange" ]; then kill -SIGUSR1 "$mainPID"; fi;;
    esac
}
checkError()
{
    [ "$errorOn" ] || return 0

    cmp --silent "$1" "$2"
    case $? in
	2) exit 1;;	# cmp had trouble
	1) if [ "$messageOnChange" ]; then kill -SIGUSR1 "$mainPID"; fi;;& # Fall-through here!
	$errorOn)
	    $action "$1" "$2" || {
		case $? in
		    255)    message "$messageOnFailure" "$file"; exit 124;;	# special COMMAND exit has precedence over abort
		esac
	    }
	    message "$messageOnError" "$file"
	    exit 1  # signal error
	    ;;
    esac
}



####D echo "**** $isNeedEval ${commands[0]}"; echo "**** ${commands[1]}"; echo "**** ${commands[2]}"; exit
tmpFile=$(mktemp --tmpdir "$(basename -- "$0")-XXXXXX" 2>/dev/null || echo "${TEMP:-/tmp}/$(basename -- "$0").$$")

interpolatedFile="$file"; [ "$isNeedEval" ] && printf -v interpolatedFile '%q' "$file"
typeset -a interpolatedCommands=("${commands[@]//\{\}/$interpolatedFile}")
typeset -a f=("$interpolatedFile")
[ "${interpolatedCommands[*]}" = "${commands[*]}" ] || f=()

if [ "$isVerbose" ]; then
    quoter='%q'; [ "$isNeedEval" ] && quoter='%s'
    if [ "$isPiped" ]; then
	[ ${#f[@]} -eq 0 -a -n "$isPiped" ] && f=("$interpolatedFile")
	printf "< $quoter " "${f[@]}"
	f=()
    fi
    printf -v verboseCommand "$quoter " "${interpolatedCommands[@]}" "${f[@]}"
    printf >&2 "%s\n" "${verboseCommand% }"
fi

if [ "$backupExtension" ]; then
    cp --force --preserve "$file" "${file}${backupExtension}" || exit $?
fi

if [ "$isPiped" ]; then
    # Note: Use $interpolatedCommands instead of $commands here; any {} would
    # be expanded in there, which might only make sense for weird corner
    # cases, so why not. Another argument is that we simply always log
    # $interpolatedCommands with --verbose, so the action should be
    # consistent with that.
    if [ "$isNeedEval" ]; then
	< "$file" eval "${interpolatedCommands[@]}" > "$tmpFile"
    else
	< "$file" "${interpolatedCommands[@]}" > "$tmpFile"
    fi
else
    if [ "$isNeedEval" ]; then
	eval "${interpolatedCommands[@]}" "${f[@]}" > "$tmpFile"
    else
	"${interpolatedCommands[@]}" "${f[@]}" > "$tmpFile"
    fi
fi && \
    $check "$tmpFile" "$file" && \
    $action "$tmpFile" "$file" && \
    if [ "$isChange" ]; then message "$messageOnChange" "$file"; else message "$messageOnSuccess" "$file"; fi || \
    {
	case $? in
	    255)    message "$messageOnFailure" "$file"; exit 124;;
	    *)	    message "$messageOnFailure" "$file"; exit 123;;
	esac
    }
