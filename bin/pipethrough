#!/bin/bash
###############################################################################
##
# FILE: 	pipethrough
# PRODUCT:	tools
# AUTHOR: 	/^--
# DATE CREATED:	01-Jan-2004
#
###############################################################################
# REVISION	DATE		REMARKS
#	016	15-Jun-2016	ENH: Support --backup EXT.
#				ENH: Support --command-arguments N.
#				ENH: Support --test-only.
#				ENH: Use on-demand quoting of all command
#				arguments and file when using --verbose.
#	015	14-Jun-2016	Use eval() instead of $SHELL, printf instead of
#				echo.
#				ENH: Support -- COMMAND -- (inspired from the
#				canonical separator between options and
#				arguments) and \; COMMAND \; (inspired by find
#				-exec) in addition to a quoted (single-argument)
#				COMMAND; quoting may be cumbersome.
#				Support --help.
#				ENH: Support (xargs-like) exit statuses and
#				aborting the iteration via exit 255.
#				ENH: Support diffing, abort on [no] change.
#				ENH: Support verbose mode.
#	014	12-Apr-2016	Use mktemp, $SHELL.
#	013	26-May-2009	Replaced Korn Shell'ish 'print -R' with 'echo'.
#	0.12	26-Sep-2006	Simplified print command.
#	0.11	18-Oct-2005	BF: fixed unwanted escaping in echo.
#	0.10	01-Jun-2004	BF: invoking ${command} via shell, because
#				commands with input redirection (e.g. "tr '\\'
#				'/' <") were hanging.
#	0.01	01-Jan-2004	file creation
###############################################################################

printShortUsage()
{
    cat <<SHORTHELPTEXT
Usage:
    $(basename "$1") [-v|--verbose] [-b|--backup EXT] [--test-only|(--diff-only|--diff [--diff-cmd CMD] [--diff-options OPT])] [--abort-unless-change|--abort-on-change] [-?|-h|--help] ...
    $(basename "$1") [...] "COMMAND [ARGUMENTS ...]" FILE [, ...]
    $(basename "$1") [...] -- COMMAND [ARGUMENTS ...] -- FILE [, ...]
    $(basename "$1") [...] \; COMMAND [ARGUMENTS ...] \; FILE [, ...]
    $(basename "$1") [...] -n|--command-arguments N COMMAND [ARGUMENTS ...] FILE [, ...]
SHORTHELPTEXT
}
printUsage()
{
    # This is the short help when launched with no or incorrect arguments.
    # It is printed to stderr to avoid accidental processing.
    printShortUsage "$1" >&2
    cat >&2 <<MOREHELP
Try "$(basename "$1")" --help for more information.
MOREHELP
}
printLongUsage()
{
    cat <<HELPDESCRIPTION
Pipes the (list of) FILEs through an external COMMAND and writes the output
back into the same FILE.
The COMMAND (and its ARGUMENTS) can be specified in various ways: As one quoted
argument, separated by special arguments -- or \;, or (especially useful in
scripts when you know the \${#ARGS[@]} but cannot influence the contents) by
number of arguments.
HELPDESCRIPTION
    echo
    printShortUsage "$1"
    cat <<HELPTEXT
    --verbose|-v	    Show each executed command on stderr.
    --backup|-b		    Create a backup of the original file with file
			    extension EXT.
    --test-only		    Just test for change, don't persist.
    --diff-only		    Only show differences done by COMMAND, don't persist.
    --diff		    Also show differences done by COMMAND, and overwrite.
    --diff-cmd CMD	    Use CMD as the diff command.
    --diff-options OPT	    Options passed to diff; default -u (unified diff).
    --abort-unless-change   Do not process further FILEs if COMMAND didn't
			    change the current FILE.
    --abort-on-change	    Do not process further FILEs if COMMAND changed the
			    current FILE.
    --command-arguments|-n N
			    The COMMAND [ARGUMENTS ...] consists of N arguments;
			    start accepting FILEs after that.

$(basename "$1") exits with the following status:
      0 if it succeeds
    123 if any invocation of the COMMAND exited with status 1-125
    124 if the COMMAND exited with status 255
      1 if the processing was aborted (--abort-on-change, --abort-unless-change)
      2 if it was invoked in a wrong way, e.g. missing FILEs
HELPTEXT
}


action=overwrite
abortOn=
backupExtension=
commandArgumentNum=
diffCommand=diff; type -t colordiff >/dev/null && diffCommand=colordiff # Highlight diff output if available.
diffOptions=-u
isVerbose=
while [ $# -ne 0 ]
do
    case "$1" in
	--help|-h|-\?)	shift; printLongUsage "$0"; exit 0;;
	--verbose|-v)	shift; isVerbose=t;;
	--backup|-b)	shift; backupExtension="$1"; shift;;
	--test-only)	shift; action=testChanges;;
	--diff-only)	shift; action=diffChanges;;
	--diff)		shift; action=diffAndOverwrite;;
	--diff-options)		shift; diffOptions="$1"; shift;;
	--diff-cmd)		shift; diffCommand="$1"; shift;;
	--abort-unless-change)	shift; abortOn=0;;
	--abort-on-change)	shift; abortOn=1;;
	--command-arguments|-n)	shift; commandArgumentNum="$1"; shift;;
	--)		break;;
	-*)		{ echo "ERROR: Unknown option \"$1\"!"; echo; printShortUsage "$0"; } >&2; exit 2;;
	*)		break;;
    esac
done
[ $# -eq 0 ] && { printUsage "$0"; exit 2; }

case "$1" in
    \;|--)
	separator=$1
	shift
	typeset -a command=()
	while [ "$1" != "$separator" ]
	do
	    command+=("$1")
	    shift
	done
	shift

	if [ ${#command[@]} -eq 0 ]; then
	    echo >&2 "ERROR: No COMMAND specified"
	    printUsage "$0"
	    exit 2
	fi
	;;
    *)
	if [ "$commandArgumentNum" ]; then
	    typeset -a command=()
	    for (( i = 0; i < $commandArgumentNum; i++ ))
	    do
		command+=("$1")
		shift
	    done
	else
	    eval "typeset -a command=($1)"
	    shift
	fi
	;;
esac



overwrite()
{
    mv -f "$1" "$2"
}
testChanges()
{
    return 0
}
diffChanges()
{
    eval "$diffCommand" "$diffOptions" '"$1" "$2"'
    return 0	# Do not interpret differences as failure; we have the separate --abort-on-change and --abort-unless-change for that.
}
diffAndOverwrite()
{
    diffChanges "$1" "$2"
    overwrite "$1" "$2"
}

checkAbort()
{
    [ "$abortOn" ] || return 0

    cmp --silent "$1" "$2"
    case $? in
	2)	    exit 1;;	# cmp had trouble
	$abortOn)
	    $action "$1" "$2" || {
		case $? in
		    255)    exit 124;;	# special COMMAND exit has precedence over abort
		esac
	    }
	    exit 1  # signal abort
	    ;;
    esac
}



####D echo "**** ${command[0]}"; echo "**** ${command[1]}"; echo "**** ${command[2]}"; exit
if [ $# -eq 0 ]; then
    echo >&2 "ERROR: No FILEs to pipe."
    printUsage "$0"
    exit 2
fi

exitStatus=0
for file
do
    tmpFile=$(mktemp --tmpdir "$(basename -- "$0")-XXXXXX" 2>/dev/null || echo "${TEMP:-/tmp}/$(basename -- "$0").$$")

    if [ "$isVerbose" ]; then
	printf >&2 '%q ' "${command[@]}" "${file}"; printf >&2 \\n
    fi

    if [ "$backupExtension" ]; then
	cp --force --preserve "$file" "${file}${backupExtension}" || exit $?
    fi

    "${command[@]}" "$file" > "$tmpFile" && checkAbort "$tmpFile" "$file" && $action "$tmpFile" "$file" || {
	case $? in
	    255)    exit 124;;
	    *)	    exitStatus=123;;
	esac
    }
done
exit $exitStatus
