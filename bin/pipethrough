#!/bin/bash
###############################################################################
##
# FILE: 	pipethrough
# PRODUCT:	tools
# AUTHOR: 	/^--
# DATE CREATED:	01-Jan-2004
#
###############################################################################
# REVISION	DATE		REMARKS
#	022	08-May-2019	FIX: Need to turn off globbing when parsing
#				command; else, a passed \* argument would turn
#				into the current list of files.
#	021	30-Apr-2019	ENH: Also support {} placeholder in COMMAND
#				as an alternative to appending the file.
#	020	15-Apr-2019	Preserve original file mode by using cp && rm
#				instead of mv: "In the absence of --preserve,
#				the permissions of existing destination files
#				are unchanged."
#	019	13-May-2018	ENH: Add --piped option for actual piping via
#				stdin. Some COMMANDs do not support FILE
#				arguments or behave differently (e.g.
#				colordiff).
#	018	17-Jun-2016	BUG: diff arguments are reversed.
#				ENH: Add --warn-on-change and
#				--warn-unless-change.
#				FIX: Correct command-line summary for
#				--message-... options.
#				FIX: Don't enable checkChanges on
#				--message-on-change ''.
#	017	16-Jun-2016	ENH: Add built-in messaging via
#				--message-on-success, --message-on-failure,
#				--message-on-abort, --message-subject; this is
#				easier for the client than checking the script's
#				exit status.
#				ENH: Add --message-on-change and support
#				checking for changes without aborting.
#	016	15-Jun-2016	ENH: Support --backup EXT.
#				ENH: Support --command-arguments N.
#				ENH: Support --test-only.
#				ENH: Use on-demand quoting of all command
#				arguments and file when using --verbose.
#	015	14-Jun-2016	Use eval() instead of $SHELL, printf instead of
#				echo.
#				ENH: Support -- COMMAND -- (inspired from the
#				canonical separator between options and
#				arguments) and \; COMMAND \; (inspired by find
#				-exec) in addition to a quoted (single-argument)
#				COMMAND; quoting may be cumbersome.
#				Support --help.
#				ENH: Support (xargs-like) exit statuses and
#				aborting the iteration via exit 255.
#				ENH: Support diffing, abort on [no] change.
#				ENH: Support verbose mode.
#	014	12-Apr-2016	Use mktemp, $SHELL.
#	013	26-May-2009	Replaced Korn Shell'ish 'print -R' with 'echo'.
#	0.12	26-Sep-2006	Simplified print command.
#	0.11	18-Oct-2005	BF: fixed unwanted escaping in echo.
#	0.10	01-Jun-2004	BF: invoking ${command} via shell, because
#				commands with input redirection (e.g. "tr '\\'
#				'/' <") were hanging.
#	0.01	01-Jan-2004	file creation
###############################################################################

printShortUsage()
{
    printf 'Usage: %q %s\n' $(basename "$1") '[-v|--verbose] [-p|--piped] [-b|--backup EXT] [--test-only|(--diff-only|--diff [--diff-cmd CMD] [--diff-options OPT])] [--abort-unless-change|--abort-on-change] [--message-on-change MSG] [--message-on-success MSG] [--message-on-failure MSG] [--message-on-abort MSG] ([--message-subject SUBJECT] [--warn-on-change|--warn-unless-change]) [-?|-h|--help] ...'
    printf 'Usage: %q %s\n' $(basename "$1") '[...] -c|--command "COMMANDLINE [{}] ..." [-c ...] FILE [, ...]'
    printf 'Usage: %q %s\n' $(basename "$1") '[...] -- SIMPLECOMMAND [ARGUMENTS ...] -- FILE [, ...]'
    printf 'Usage: %q %s\n' $(basename "$1") '[...] \; SIMPLECOMMAND [ARGUMENTS ...] \; FILE [, ...]'
    printf 'Usage: %q %s\n' $(basename "$1") '[...] -n|--command-arguments N SIMPLECOMMAND [ARGUMENTS ...] FILE [, ...]'
}
printUsage()
{
    # This is the short help when launched with no or incorrect arguments.
    # It is printed to stderr to avoid accidental processing.
    printShortUsage "$1" >&2
    printf >&2 'Try %q --help for more information.\n' "$(basename "$1")"
}
printLongUsage()
{
    cat <<HELPDESCRIPTION
Passes FILEs individually through an external COMMAND (by passing the FILE spec
as the last command-line argument, or replacing any {} marker inside COMMAND, or
alternatively piping the FILE contents in through standard input) and writes the
output back into the same FILE.
The COMMAND (and its ARGUMENTS) can be specified in various ways: As one quoted
argument, separated by special arguments -- or \;, or (especially useful in
scripts when you know the \${#ARGS[@]} but cannot influence the contents) by
number of arguments.
HELPDESCRIPTION
    echo
    printShortUsage "$1"
    cat <<HELPTEXT
    --verbose|-v	    Show each executed command on stderr.
    --piped|-p		    Pass FILE contents via stdin into COMMAND instead of
			    by appending FILE as the last command-line argument.
    --backup|-b		    Create a backup of the original file with file
			    extension EXT.
    --test-only		    Just test for change, don't persist.
    --diff-only		    Only show differences done by COMMAND, don't persist.
    --diff		    Also show differences done by COMMAND, and overwrite.
    --diff-cmd CMD	    Use CMD as the diff command.
    --diff-options OPT	    Options passed to diff; default -u (unified diff).
    --abort-unless-change   Do not process further FILEs if COMMAND didn't
			    change the current FILE.
    --abort-on-change	    Do not process further FILEs if COMMAND changed the
			    current FILE.
    --message-on-change MSG Print MSG to stderr if COMMAND changed the FILE.
    --message-on-success MSG
			    Print MSG to stderr if COMMAND succeeds.
    --message-on-failure MSG
			    Print MSG to stderr if COMMAND fails.
    --message-on-abort MSG  Print MSG to stderr if processing was aborted
			    (--abort-on-change, --abort-unless-change).
			    The current FILE can be embedded in the message via
			    %q.
    --message-subject SUBJECT
			    Print a status message (change, success, failure,
			    abort) to stderr. Basically all of the
			    --message-on-... options in one. Individual messages
			    can still be overridden via the --message-on-...
			    parameters.
    --warn-on-change	    The status message on change will be a warning
			    message instead of an informational one.
    --warn-unless-change    The status message on success (without change) will
			    be a warning message instead of an informational
			    one.
    --command-arguments|-n N
			    The COMMAND [ARGUMENTS ...] consists of N arguments;
			    start accepting FILEs after that.
EXIT STATUS:
      0 if it succeeds
    123 if any invocation of the COMMAND exited with status 1-125
    124 if the COMMAND exited with status 255
      1 if the processing was aborted (--abort-on-change, --abort-unless-change)
      2 if it was invoked in a wrong way, e.g. missing FILEs
HELPTEXT
}


isNeedEval=
typeset -a commands=()
action=overwrite
check=:
abortOn=
backupExtension=
commandArgumentNum=
diffCommand=diff; type -t colordiff >/dev/null && diffCommand=colordiff # Highlight diff output if available.
diffOptions=-u
isPiped=
verbosePiped=
isVerbose=
warnOn=
unset messageOnChange
unset messageOnSuccess
unset messageOnFailure
unset messageOnAbort
messageSubject=
while [ $# -ne 0 ]
do
    case "$1" in
	--help|-h|-\?)	shift; printLongUsage "$0"; exit 0;;
	--command|-c)	shift; commands+=(${commands:+;} "$1"); isNeedEval=t; shift;;
	--verbose|-v)	shift; isVerbose=t;;
	--piped|-p)	shift; isPiped=t; verbosePiped='< ';;
	--backup|-b)	shift; backupExtension="$1"; shift;;
	--test-only)	shift; action=testChanges;;
	--diff-only)	shift; action=diffChanges;;
	--diff)		shift; action=diffAndOverwrite;;
	--diff-options)		shift; diffOptions="$1"; shift;;
	--diff-cmd)		shift; diffCommand="$1"; shift;;
	--abort-unless-change)	shift
				if [ "$abortOn" = 1 ]; then
				    echo >&2 "ERROR: Cannot specify both --abort-unless-change and --abort-on-change at once!"
				    printShortUsage "$0"
				    exit 2;
				fi
				check=checkAbort
				abortOn=0
				;;
	--abort-on-change)	shift
				if [ "$abortOn" = 0 ]; then
				    echo >&2 "ERROR: Cannot specify both --abort-unless-change and --abort-on-change at once!"
				    printShortUsage "$0"
				    exit 2;
				fi
				check=checkAbort
				abortOn=1
				;;
	--message-on-change)	shift
				[ "$1" -a "$check" = ':' ] && check=checkChanges
				messageOnChange="$1"
				shift
				;;
	--message-on-success)		shift; messageOnSuccess="$1"; shift;;
	--message-on-failure)		shift; messageOnFailure="$1"; shift;;
	--message-on-abort)		shift; messageOnAbort="$1"; shift;;
	--message-subject)		shift; messageSubject="$1"; shift;;
	--warn-on-change)		shift; warnOn=1;;
	--warn-unless-change)		shift; warnOn=0;;
	--command-arguments|-n)	shift; commandArgumentNum="$1"; shift;;
	--)		break;;
	-*)		{ echo "ERROR: Unknown option \"$1\"!"; echo; printShortUsage "$0"; } >&2; exit 2;;
	*)		break;;
    esac
done
if [ $# -eq 0 ]; then
    printUsage "$0" >&2
    exit 2
fi
if [ "$messageSubject" ]; then
    if [ ! "${messageOnChange+t}" ]; then
	case "$warnOn" in
	    1)	messageOnChange="Warning: $messageSubject changed %q";;
	    *)	messageOnChange="$messageSubject changed %q";;
	esac
	[ "$check" = ':' ] && check=checkChanges
    fi
    case "$warnOn" in
	0)  if [ "$check" = ':' ]; then
		echo >&2 "ERROR: --warn-unless-change cannot be specified when change checking isn't enabled"
		exit 2
	    fi
	    : ${messageOnSuccess="Warning: $messageSubject did not change %q"}
	    ;;
	*)  : ${messageOnSuccess="Successfully performed $messageSubject on %q"};;
    esac
    : ${messageOnFailure="ERROR: Failed to $messageSubject on %q"}
    case "$abortOn" in
	0)  : ${messageOnAbort="ERROR: Aborted because $messageSubject did not change %q"};;
	1)  : ${messageOnAbort="ERROR: Aborted because $messageSubject changed %q"};;
    esac
fi

case "$1" in
    \;|--)
	separator=$1
	shift
	while [ "$1" != "$separator" ]
	do
	    simpleCommand+=("$1")
	    shift
	done
	shift
	;;
    *)
	if [ "$commandArgumentNum" ]; then
	    for (( i = 0; i < $commandArgumentNum; i++ ))
	    do
		simpleCommand+=("$1")
		shift
	    done
	fi
	;;
esac
if [ ${#simpleCommand[@]} -gt 0 ]; then
    if [ "$isNeedEval" ]; then
	# Combine --command and SIMPLECOMMAND; need to quote SIMPLECOMMAND to
	# undo the effects of eval.
	printf -v quotedSimpleCommand '%q ' "${simpleCommand[@]}"
	commands+=(${commands:+;} "${quotedSimpleCommand//\\\{\\\}/\{\}}")	# %q escapes {}, we don't want that to have it interpolated later.
    else
	commands=("${simpleCommand[@]}")
    fi
fi
if [ ${#commands[@]} -eq 0 ]; then
    echo >&2 'ERROR: No COMMAND(s) specified; need to pass -c|--command "COMMANDLINE", or SIMPLECOMMAND.'
    exit 2
fi



message()
{
    if [ "$1" ]; then
	printf "$1\\n" "$2"
    fi
}

overwrite()
{
    cp --force -- "$1" "$2" && rm --force -- "$1"
}
testChanges()
{
    return 0
}
diffChanges()
{
    eval "$diffCommand" "$diffOptions" '"$2" "$1"'
    return 0	# Do not interpret differences as failure; we have the separate --abort-on-change and --abort-unless-change for that.
}
diffAndOverwrite()
{
    diffChanges "$1" "$2"
    overwrite "$1" "$2"
}

# The $check is done in a subprocess, so we need to send a signal to the main
# script in order to pass the information about whether a change has been done.
mainPID=$$
isChange=
onChangeReported()
{
    isChange=t
}
trap onChangeReported SIGUSR1
checkChanges()
{
    cmp --silent "$1" "$2"
    case $? in
	2) exit 1;;	# cmp had trouble
	1) if [ "$messageOnChange" ]; then kill -SIGUSR1 "$mainPID"; fi;;
    esac
}
checkAbort()
{
    [ "$abortOn" ] || return 0

    cmp --silent "$1" "$2"
    case $? in
	2) exit 1;;	# cmp had trouble
	1) if [ "$messageOnChange" ]; then kill -SIGUSR1 "$mainPID"; fi;;& # Fall-through here!
	$abortOn)
	    $action "$1" "$2" || {
		case $? in
		    255)    message "$messageOnFailure" "$file"; exit 124;;	# special COMMAND exit has precedence over abort
		esac
	    }
	    message "$messageOnAbort" "$file"
	    exit 1  # signal abort
	    ;;
    esac
}



####D echo "**** $isNeedEval ${commands[0]}"; echo "**** ${commands[1]}"; echo "**** ${commands[2]}"; exit
if [ $# -eq 0 ]; then
    echo >&2 "ERROR: No FILEs to pipe."
    printUsage "$0"
    exit 2
fi

exitStatus=0
for file
do
    tmpFile=$(mktemp --tmpdir "$(basename -- "$0")-XXXXXX" 2>/dev/null || echo "${TEMP:-/tmp}/$(basename -- "$0").$$")

    interpolatedFile="$file"; [ "$isNeedEval" ] && printf -v interpolatedFile '%q' "$file"
    typeset -a interpolatedCommands=("${commands[@]//\{\}/$interpolatedFile}")
    typeset -a f=("$interpolatedFile")
    [ "${interpolatedCommands[*]}" = "${commands[*]}" ] || f=()

    if [ "$isVerbose" ]; then
	quoter='%q'; [ "$isNeedEval" ] && quoter='%s'
	printf >&2 "$quoter " "${interpolatedCommands[@]}"
	[ ${#f[@]} -eq 0 ] && quoter='%s'
	printf >&2 "${verbosePiped}${quoter}\n" "${f[@]}"
    fi

    if [ "$backupExtension" ]; then
	cp --force --preserve "$file" "${file}${backupExtension}" || exit $?
    fi

    isChange=
    if [ "$isPiped" ]; then
	# Note: Use $interpolatedCommands instead of $commands here; any {} would
	# be expanded in there, which might only make sense for weird corner
	# cases, so why not. Another argument is that we simply always log
	# $interpolatedCommands with --verbose, so the action should be
	# consistent with that.
	if [ "$isNeedEval" ]; then
	    eval "${interpolatedCommands[@]}" < "$file" > "$tmpFile"
	else
	    "${interpolatedCommands[@]}" < "$file" > "$tmpFile"
	fi
    else
	if [ "$isNeedEval" ]; then
	    eval "${interpolatedCommands[@]}" "${f[@]}" > "$tmpFile"
	else
	    "${interpolatedCommands[@]}" "${f[@]}" > "$tmpFile"
	fi
    fi && \
	$check "$tmpFile" "$file" && \
	$action "$tmpFile" "$file" && \
	if [ "$isChange" ]; then message "$messageOnChange" "$file"; else message "$messageOnSuccess" "$file"; fi || \
	{
	    case $? in
		255)    message "$messageOnFailure" "$file"; exit 124;;
		*)	message "$messageOnFailure" "$file"; exitStatus=123;;
	    esac
	}
done
exit $exitStatus
