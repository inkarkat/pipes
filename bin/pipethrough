#!/bin/bash
###############################################################################
##
# FILE:		pipethrough
# PRODUCT:	pipes
# AUTHOR:	Ingo Karkat <ingo@karkat.de>
# DATE CREATED:	01-Jan-2004
#
###############################################################################
# CONTENTS:
#   Pass FILEs individually through external COMMAND and write output back into
#   the same file.
#
# REMARKS:
#
# @(#)pipethrough	$Id$	pipes
###############################################################################

: ${PIPETHROUGH_FILE_MARKER='{}'}
fileMarker="$PIPETHROUGH_FILE_MARKER"; unset PIPETHROUGH_FILE_MARKER

printShortUsage()
{
    printf 'Usage: %q %s\n' $(basename "$1") '[-v|--verbose] [-p|--piped] [-b|--backup EXT|--backup-command writeorig|writebackup|writeOrigOrBackup] [--test-only|(--diff-only|--diff [--diff-cmd CMD] [--diff-options OPT])] [--abort-unless-change|--abort-on-change] [--message-on-change MSG] [--message-on-success MSG] [--message-on-failure MSG] [--message-on-abort MSG] [--message-subject SUBJECT [--warn-on-change|--warn-unless-change]] [-?|-h|--help] ...'
    printf 'Usage: %q %s\n' $(basename "$1") "[...] -c|--command \"COMMANDLINE [${fileMarker}] ...\" [-c ...] FILE [, ...]"
    printf 'Usage: %q %s\n' $(basename "$1") "[...] --exec SIMPLECOMMAND [${fileMarker}] [ARGUMENTS ...] ; FILE [, ...]"
    printf 'Usage: %q %s\n' $(basename "$1") "[...] -- SIMPLECOMMAND [${fileMarker}] [ARGUMENTS ...] -- FILE [, ...]"
    printf 'Usage: %q %s\n' $(basename "$1") "[...] -n|--command-arguments N SIMPLECOMMAND [${fileMarker}] [ARGUMENTS ...] FILE [, ...]"
}
printUsage()
{
    # This is the short help when launched with no or incorrect arguments.
    # It is printed to stderr to avoid accidental processing.
    printShortUsage "$1" >&2
    printf >&2 '\nTry %q --help for more information.\n' "$(basename "$1")"
}
printLongUsage()
{
    cat <<HELPDESCRIPTION
Passes FILEs individually through external COMMAND(s) (by passing the FILE spec
as the last command-line argument${fileMarker:+, or replacing any $fileMarker marker inside COMMAND}, or
alternatively piping the FILE contents in through standard input) and writes the
output back into the same FILE.
COMMAND (and its ARGUMENTS) can be specified in various ways: As one quoted
argument with -c|--command, arguments after --exec until a ';', separated by
special arguments --, or (especially useful in scripts when you know the
\${#ARGS[@]} but cannot influence the contents) by number of arguments.
HELPDESCRIPTION
    echo
    printShortUsage "$1"
    echo
    cat <<HELPTEXT
    --verbose|-v	    Show each executed command on stderr.
    --piped|-p		    Pass FILE contents via stdin into COMMAND instead of
			    by appending FILE as the last command-line argument.
    --backup|-b EXT	    Create a backup of the original file with file
			    extension EXT.
    --backup-command writeorig|writebackup|writeOrigOrBackup
			    Use the supplied backup program for backup.
    --test-only		    Just test for change, don't persist.
    --diff-only		    Only show differences done by COMMAND, don't
			    persist.
    --diff		    Also show differences done by COMMAND, and
			    overwrite.
    --diff-cmd CMD	    Use CMD as the diff command.
    --diff-options OPT	    Options passed to diff; default -u (unified diff).
    --abort-unless-change   Do not process further FILEs if COMMAND didn't
			    change the current FILE.
    --abort-on-change	    Do not process further FILEs if COMMAND changed the
			    current FILE.
    --message-on-change MSG Print MSG to stderr if COMMAND changed the FILE.
    --message-on-success MSG
			    Print MSG to stderr if COMMAND succeeds. If
			    --message-on-change is also given, this will be the
			    warning that no change happened.
    --message-on-failure MSG
			    Print MSG to stderr if COMMAND fails.
    --message-on-abort MSG  Print MSG to stderr if processing was aborted
			    (--abort-on-change, --abort-unless-change).
    The current FILE can be embedded in any message via %q.
    --message-subject SUBJECT
			    Print a status message (change, success, failure,
			    abort) to stderr. Basically all of the
			    --message-on-... options in one. Individual messages
			    can still be overridden via the --message-on-...
			    parameters.
    --warn-on-change	    Modifies the status messages synthesized by
			    --message-subject so that on change it will be a
			    warning message instead of an informational one.
    --warn-unless-change    Modifies the status messages synthesized by
			    --message-subject so that on success (without
			    change) it will be a warning message instead of an
			    informational one.
    --command|-c CMD	    Execute CMD as a command-line. Each FILE ${fileMarker:+either }is
			    appended${fileMarker:+ or replaces any $fileMarker marker} inside
			    COMMANDLINE.
    --exec COMMAND ... ;    Execute COMMAND; all following arguments are taken
			    to be arguments to the COMMAND until an argument
			    consisting of ';' is encountered. Each FILE ${fileMarker:+either}
			    is appended${fileMarker:+ or replaces any $fileMarker marker} inside
			    COMMANDLINE.
    --command-arguments|-n N
			    The COMMAND [ARGUMENTS ...] consists of N arguments;
			    start accepting FILEs after that.
EXIT STATUS:
    0	if it succeeds
    123	if any invocation of the COMMAND exited with status 1-125
    124	if the COMMAND exited with status 255
    1	if the processing was aborted (--abort-on-change, --abort-unless-change)
    2	if it was invoked in a wrong way, e.g. missing FILEs
    3	Internal error or failed assertion.
HELPTEXT
}

isNeedEval=
typeset -a commands=()
typeset -a simpleCommand=()
action=overwrite
check=:
abortOn=
backupExtension=
backupCommand=
commandArgumentNum=
diffCommand=diff; type -t colordiff >/dev/null && diffCommand=colordiff # Highlight diff output if available.
diffOptions=-u
isPiped=
commandJoiner=';'
isVerbose=
warnOn=
unset messageOnChange
unset messageOnSuccess
unset messageOnFailure
unset messageOnAbort
messageSubject=
while [ $# -ne 0 ]
do
    case "$1" in
	--help|-h|-\?)	shift; printLongUsage "$0"; exit 0;;
	--command|-c)	shift; commands+=(${commands:+$commandJoiner} "$1"); isNeedEval=t; shift;;
	--exec)		shift
			while [ $# -gt 0 -a "$1" != ';' ]
			do
			    simpleCommand+=("$1")
			    shift
			done
			if [ $# -eq 0 ]; then
			    echo 'ERROR: -exec command must be concluded with ;!'; echo; printUsage "$0"
			    exit 2
			fi >&2
			shift
			;;
	--verbose|-v)	shift; isVerbose=t;;
	--piped|-p)	shift; isPiped=t; commandJoiner='|';;
	--backup|-b)	shift; backupExtension="$1"; shift; backupCommand=backupToExtension;;
	--backup-command)
			shift; backupCommand="$1"; shift;;
	--test-only)	shift; action=testChanges;;
	--diff-only)	shift; action=diffChanges;;
	--diff)		shift; action=diffAndOverwrite;;
	--diff-options)		shift; diffOptions="$1"; shift;;
	--diff-cmd)		shift; diffCommand="$1"; shift;;
	--abort-unless-change)	shift
				if [ "$abortOn" = 1 ]; then
				    echo "ERROR: Cannot specify both --abort-unless-change and --abort-on-change at once!"
				    echo
				    printUsage "$0"
				    exit 2;
				fi >&2
				check=checkAbort
				abortOn=0
				;;
	--abort-on-change)	shift
				if [ "$abortOn" = 0 ]; then
				    echo "ERROR: Cannot specify both --abort-unless-change and --abort-on-change at once!"
				    echo
				    printUsage "$0"
				    exit 2;
				fi >&2
				check=checkAbort
				abortOn=1
				;;
	--message-on-change)	shift
				[ "$1" -a "$check" = ':' ] && check=checkChanges
				messageOnChange="$1"
				shift
				;;
	--message-on-success)		shift; messageOnSuccess="$1"; shift;;
	--message-on-failure)		shift; messageOnFailure="$1"; shift;;
	--message-on-abort)		shift; messageOnAbort="$1"; shift;;
	--message-subject)		shift; messageSubject="$1"; shift;;
	--warn-on-change)		shift; warnOn=1;;
	--warn-unless-change)		shift; warnOn=0;;
	--command-arguments|-n)	shift; commandArgumentNum="$1"; shift;;
	--)		break;;
	-*)		{ echo "ERROR: Unknown option \"$1\"!"; echo; printUsage "$0"; } >&2; exit 2;;
	*)		break;;
    esac
done
if [ $# -eq 0 ]; then
    printUsage "$0" >&2
    exit 2
fi
if [ "$messageSubject" ]; then
    if [ ! "${messageOnChange+t}" ]; then
	case "$warnOn" in
	    1)	messageOnChange="Warning: $messageSubject changed %q";;
	    *)	messageOnChange="$messageSubject changed %q";;
	esac
	[ "$check" = ':' ] && check=checkChanges
    fi
    case "$warnOn" in
	0)  if [ "$check" = ':' ]; then
		echo >&2 "ERROR: --warn-unless-change cannot be specified when change checking isn't enabled"
		exit 2
	    fi
	    : ${messageOnSuccess="Warning: $messageSubject did not change %q"}
	    ;;
	*)  if [ "$check" = ':' ]; then
		: ${messageOnSuccess="Successfully performed $messageSubject on %q"}
	    else
		: ${messageOnSuccess="Successfully performed $messageSubject on %q without changing it"}
	    fi
	    ;;
    esac
    : ${messageOnFailure="ERROR: Failed to $messageSubject on %q"}
    case "$abortOn" in
	0)  : ${messageOnAbort="ERROR: Aborted because $messageSubject did not change %q"};;
	1)  : ${messageOnAbort="ERROR: Aborted because $messageSubject changed %q"};;
    esac
fi

case "$1" in
    --)
	shift
	while [ $# -gt 0 -a "$1" != '--' ]
	do
	    simpleCommand+=("$1")
	    shift
	done
	if [ $# -eq 0 ]; then
	    echo 'ERROR: -- SIMPLECOMMAND [ARGUMENTS ...] must be concluded with --!'; echo; printUsage "$0"
	    exit 2
	fi >&2
	shift
	;;
    *)
	if [ "$commandArgumentNum" ]; then
	    for (( i = 0; i < commandArgumentNum; i++ ))
	    do
		simpleCommand+=("$1")
		shift
	    done
	fi
	;;
esac
if [ ${#simpleCommand[@]} -gt 0 ]; then
    if [ "$isNeedEval" ]; then
	# Combine --command and SIMPLECOMMAND; need to quote SIMPLECOMMAND to
	# undo the effects of eval.
	printf -v quotedSimpleCommand '%q ' "${simpleCommand[@]}"
	quotedSimpleCommand="${quotedSimpleCommand% }"
	printf -v escapedFileMarker %q "$fileMarker"
	commands+=(${commands:+$commandJoiner} "${quotedSimpleCommand//"$escapedFileMarker"/$fileMarker}")	# %q escapes {}, we don't want that to have it interpolated later.
    else
	commands=("${simpleCommand[@]}")
    fi
fi
if [ ${#commands[@]} -eq 0 ]; then
    echo >&2 'ERROR: No COMMAND(s) specified; need to pass -c|--command "COMMANDLINE", or SIMPLECOMMAND.'
    exit 2
fi



message()
{
    if [ "$1" ]; then
	printf "$1\\n" "$2"
    fi
}

overwrite()
{
    if [ -h "$2" -a ! -e "$2" ]; then
	cat -- "$1" > "$2"	# Shell redirection re-creates a dangling symlink instead of failing like cp.
    else
	cp --force -- "$1" "$2"	# Preserve original file mode by using cp && rm instead of mv: "In the absence of --preserve, the permissions of existing destination files are unchanged."
    fi && rm --force -- "$1"
}
testChanges()
{
    return 0
}
diffChanges()
{
    eval "$diffCommand" "$diffOptions" '"$2" "$1"'
    return 0	# Do not interpret differences as failure; we have the separate --abort-on-change and --abort-unless-change for that.
}
diffAndOverwrite()
{
    diffChanges "$1" "$2"
    overwrite "$1" "$2"
}
backupToExtension()
{
    local filespec="${1:?}"; shift
    cp --force --preserve "$filespec" "${filespec}${backupExtension}"
}

# The $check is done in a subprocess, so we need to send a signal to the main
# script in order to pass the information about whether a change has been done.
mainPID=$$
isChange=
onChangeReported()
{
    isChange=t
}
trap onChangeReported SIGUSR1
checkChanges()
{
    local updatedFilespec="${1:?}"; shift
    local file="${1:?}"; shift

    cmp --silent "$updatedFilespec" "$file"
    case $? in
	2) exit 3;;	# cmp had trouble
	1) if [ "$messageOnChange" ]; then kill -SIGUSR1 "$mainPID"; fi;;
    esac
}
checkAbort()
{
    local updatedFilespec="${1:?}"; shift
    local file="${1:?}"; shift
    [ "$abortOn" ] || return 0

    cmp --silent "$updatedFilespec" "$file"
    case $? in
	2) exit 3;;	# cmp had trouble
	1) if [ "$messageOnChange" ]; then kill -SIGUSR1 "$mainPID"; fi;;& # Fall-through here!
	$abortOn)
	    $action "$updatedFilespec" "$file" || {
		case $? in
		    255)    message "$messageOnFailure" "$file"; exit 124;;	# special COMMAND exit has precedence over abort
		esac
	    }
	    message "$messageOnAbort" "$file"
	    exit 1  # signal abort
	    ;;
    esac
}



####D echo "**** $isNeedEval ${commands[0]}"; echo "**** ${commands[1]}"; echo "**** ${commands[2]}"; exit
if [ $# -eq 0 ]; then
    echo >&2 "ERROR: No FILEs to pipe."
    printUsage "$0"
    exit 2
fi

exitStatus=0
for file
do
    tmpFile=$(mktemp --tmpdir "$(basename -- "$0")-XXXXXX" 2>/dev/null || echo "${TEMP:-/tmp}/$(basename -- "$0").$$")

    interpolatedFile="$file"; [ "$isNeedEval" ] && printf -v interpolatedFile '%q' "$file"
    typeset -a interpolatedCommands=("${commands[@]//"$fileMarker"/$interpolatedFile}")
    typeset -a f=("$interpolatedFile")
    [ "${interpolatedCommands[*]}" = "${commands[*]}" ] || f=()

    if [ "$isVerbose" ]; then
	quoter='%q'; [ "$isNeedEval" ] && quoter='%s'
	if [ "$isPiped" ]; then
	    [ ${#f[@]} -eq 0 -a -n "$isPiped" ] && f=("$interpolatedFile")
	    printf "< $quoter " "${f[@]}"
	    f=()
	fi
	printf -v verboseCommand "$quoter " "${interpolatedCommands[@]}" "${f[@]}"
	printf >&2 "%s\n" "${verboseCommand% }"
    fi

    if [ -n "$backupCommand" ]; then
	$backupCommand "$file" || exit $?
    fi

    isChange=
    if [ "$isPiped" ]; then
	# Note: Use $interpolatedCommands instead of $commands here; any {} would
	# be expanded in there, which might only make sense for weird corner
	# cases, so why not. Another argument is that we simply always log
	# $interpolatedCommands with --verbose, so the action should be
	# consistent with that.
	if [ "$isNeedEval" ]; then
	    < "$file" eval "${interpolatedCommands[@]}" > "$tmpFile"
	else
	    < "$file" "${interpolatedCommands[@]}" > "$tmpFile"
	fi
    else
	if [ "$isNeedEval" ]; then
	    eval "${interpolatedCommands[@]}" "${f[@]}" > "$tmpFile"
	else
	    "${interpolatedCommands[@]}" "${f[@]}" > "$tmpFile"
	fi
    fi && \
	$check "$tmpFile" "$file" && \
	$action "$tmpFile" "$file" && \
	if [ "$isChange" ]; then message "$messageOnChange" "$file"; else message "$messageOnSuccess" "$file"; fi || \
	{
	    case $? in
		3)	exit 3;;
		255)    message "$messageOnFailure" "$file"; exit 124;;
		*)	message "$messageOnFailure" "$file"; exitStatus=123;;
	    esac
	}
done
exit $exitStatus
