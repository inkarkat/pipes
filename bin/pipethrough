#!/bin/bash
###############################################################################
##
# FILE: 	pipethrough
# PRODUCT:	tools
# AUTHOR: 	/^--
# DATE CREATED:	01-Jan-2004
#
###############################################################################
# PURPOSE:
#   Pipes the (list of) files through an external command and writes the output
#   back into the file.
# INPUTS:
#   first argument: command (e.g. dos2ux)
#   next arguments: files to be modified
# RETURN VALUES:
#   none
# REVISION	DATE		REMARKS
#	015	14-Jun-2016	Use eval() instead of $SHELL, printf instead of
#				echo.
#				ENH: Support -- COMMAND -- (inspired from the
#				canonical separator between options and
#				arguments) and \; COMMAND \; (inspired by find
#				-exec) in addition to a quoted (single-argument)
#				COMMAND; quoting may be cumbersome.
#				Support --help.
#	014	12-Apr-2016	Use mktemp, $SHELL.
#	013	26-May-2009	Replaced Korn Shell'ish 'print -R' with 'echo'.
#	0.12	26-Sep-2006	Simplified print command.
#	0.11	18-Oct-2005	BF: fixed unwanted escaping in echo.
#	0.10	01-Jun-2004	BF: invoking ${command} via shell, because
#				commands with input redirection (e.g. "tr '\\'
#				'/' <") were hanging.
#	0.01	01-Jan-2004	file creation
###############################################################################

printUsage()
{
    cat <<HELPTEXT
Usage:
    $(basename "$1") "COMMAND [ARGUMENTS ...]" FILE [, ...]
    $(basename "$1") -- COMMAND [ARGUMENTS ...] -- FILE [, ...]
    $(basename "$1") \; COMMAND [ARGUMENTS ...] \; FILE [, ...]
$(basename "$1") exits with the following status:
      0 if it succeeds
    123 if any invocation of the COMMAND exited with status 1-125
    124 if the COMMAND exited with status 255
      1 if some other error occurred
      2 if it was invoked in a wrong way, e.g. missing FILEs
HELPTEXT
}

case "$1" in
    --help|-h|-\?)	shift; printUsage "$0"; exit 0;;
esac
if [ $# -eq 0 ]; then
    printUsage "$0"
    exit 2
fi

case "$1" in
    \;|--)
	separator=$1
	shift
	typeset -a command
	while [ "$1" != "$separator" ]
	do
	    command+=("$1")
	    shift
	done
	shift

	if [ ${#command[@]} -eq 0 ]; then
	    echo >&2 "ERROR: No COMMAND specified"
	    printUsage "$0"
	    exit 2
	fi
	;;
    *)
	eval "typeset -a command=($1)"
	shift
	;;
esac



####D echo "**** ${command[0]}"; echo "**** ${command[1]}"; echo "**** ${command[2]}"; exit
if [ $# -eq 0 ]; then
    echo >&2 "ERROR: No FILEs to pipe."
    printUsage "$0"
    exit 2
fi

for file
do
    tmpFile=$(mktemp --tmpdir "$(basename -- "$0")-XXXXXX" 2>/dev/null || echo "${TEMP:-/tmp}/$(basename -- "$0").$$")
    printf >&2 '%s\n' "${command} '${file}'"
    "${command[@]}" "$file" > "$tmpFile" && mv -f "$tmpFile" "$file"
done
